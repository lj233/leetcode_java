# jvm

## 马士兵视频

### 命令

java -X 输出 不标准的参数  

java -XX 不稳定的参数  根据各版本不同

java -XX:PrintFlagsFinal 查看最后的 、调优后的参数

-Xms 和 -Xmx 最好大小一样 避免不必要的扩容和收缩

-XX:+PrintGC  打印日志


jps  列出 java进程


jstack (| more) 打印线程栈 jps+jstack  prio 优先级

jinfo pid 查看进程的虚拟机信息


jstat -gc pid 输出gc的情况

jmap 查看有多少对象产生  产生堆转储文件 会暂停运行的用户线程 线上不能这么作

arthas 阿里开源的 代替 jvisualvm 需要开端口才能远程 不安全

# cms和G1

## 1 CMS收集器
    CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。
    
    CMS收集器仅作用于老年代的收集，是基于标记-清除算法的，它的运作过程分为4个步骤：
    
    初始标记（CMS initial mark）STW
    并发标记（CMS concurrent mark）
    重新标记（CMS remark）STW
    并发清除（CMS concurrent sweep）
    
   + CMS收集器优点：并发收集、低停顿。
    
   + CMS收集器缺点：
    
    CMS收集器对CPU资源非常敏感。
    CMS收集器是基于标记-清除算法，该算法的缺点都有,所以只能在老年代运行
    预留内存无法满足需要就会启动 Serial Old 

## 2 G1收集器
    G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。
    这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。
    区域划分的好处就是带来了停顿时间可预测的收集模型：
    用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性
    
   + G1与CMS的特征对比如下：
    
    特征	    G1	CMS
    并发和分代	是	是
    最大化释放堆内存	是	否
    低延时	    是	是
    吞吐量	    高	低
    压实	    是	否
    可预测性	    强	弱
    新生代和老年代的物理隔离	否	是
   + G1具备如下特点：
   
           并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-the-world停顿的时间，  
                        部分其他收集器原来需要停顿Java线程执行的GC操作，G1收集器仍然可以通过并发的方式让Java程序继续运行。
           分代收集
           空间整合：与CMS的标记-清除算法不同，G1从整体来看是基于标记-整理算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。  
           但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。  
           这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
           可预测的停顿：这是G1相对于CMS的一个优势，降低停顿时间是G1和CMS共同的关注点。
   + garbage first       
   
           G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。
           G1会通过一个合理的计算模型，计算出每个Region的收集成本并量化，
           这样一来，收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的Regions作为收集目标，
           让其收集开销满足这个限制条件，以此达到实时收集的目的。
           
   + G1收集的运作过程大致如下：
   
           初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。
           并发标记（Concurrent Marking）：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。
           最终标记（Final Marking）：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。
           筛选回收（Live Data Counting and Evacuation）：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。
           
           全局变量和栈中引用的对象是可以列入根集合的，这样在寻找垃圾时，就可以从根集合出发扫描堆空间。在G1中，引入了一种新的能加入根集合的类型，就是记忆集（Remembered Set）。Remembered Sets（也叫RSets）用来跟踪对象引用。G1的很多开源都是源自Remembered Set，  
           例如，它通常约占Heap大小的20%或更高。并且，我们进行对象复制的时候，因为需要扫描和更改Card Table的信息，这个速度影响了复制的速度，进而影响暂停时间

#卡表（Card Table）

有个场景，老年代的对象可能引用新生代的对象，那标记存活对象的时候，需要扫描老年代中的所有对象。因为该对象拥有对新生代对象的引用，那么这个引用也会被称为GC Roots。那不是得又做全堆扫描？成本太高了吧。

HotSpot给出的解决方案是一项叫做卡表（Card Table）的技术。该技术将整个堆划分为一个个大小为512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。

在进行Minor GC的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到Minor GC的GC Roots里。当完成所有脏卡的扫描之后，Java虚拟机便会将所有脏卡的标识位清零。

想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么Java虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。

卡表能用于减少老年代的全堆空间扫描，这能很大的提升GC效率
      
# 类加载过程 

.java -> .class ->(按需加载) classLoader -> class对象

启动类加载器 Bootstrap（c）   java-home/jre/lib
扩展类加载器 extension   lib/ext
应用类加载器 application (程序使用java命令启动的，找的是target/classes)  加载classPath路径下的类

+ 加载 加载二进制流，内存中生成class对象，作为这个类各种数据访问的入口  
+ 验证 确保被加载的类的正确性。  
+ 准备 为类的静态变量分配内存，并将其赋默认值，final修饰的直接赋值  
+ 解析  将常量池中的符号引用替换为直接引用（内存地址）的过程。将类、名称、方法的名称和描述符替换为直接指向目标的指针  
+ 初始化 为类的静态变量赋初值  

# 类加载器 和双亲委派模型 

clazz.getClassLoader

在JVM启动时，BootStrapLoader会加载一些JVM自身运行所需的class  
在JVM启动时，ExtClassLoader会加载指定目录下一些特殊的class  
在JVM启动时，AppClassLoader会加载classpath路径下的class，以及main函数所在的类的class文件  

## 打破双亲委派
重写loadClass方法
不指定父类


# 自定义类加载器
继承classLoader
重写 findclass()方法 因为要加载Object，要跳过app加载器
使用 自定义加载器的loadClass加载

