    
# 数据库

    存储引擎主要有： 1. MyIsam 不支持事务 , 2. InnoDB 支持事务和行锁 , 3. Memory 处理速度快，安全性不高, 4. Archive, 5. Federated 。

>MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。  
也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。  
这种索引的模式被称为非聚集索引。  
不支持行级锁、非事务性存储引擎  
支持在读取时插入数据（并发插入）  
可以压缩表
 
>    Innodb引擎的索引的数据结构也是B+树，只不过数据结构-》**_叶子节点_** 中存储的都是实际的数据，这种索引有被称为聚集索引。
支持行级锁、支持事务、支持外键、支持所有事务隔离级别、支持热备份  XtraBackup
    

    
## 数据库范式
    
第一范式(1st NF －列都是不可再分)（中国北京市-》中国 - 北京市）

    第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元（也称为最小的原子
    单元），则满足第一范式（1NF）

第二范式(2nd NF－每个表只描述一件事情)
    
    （订单分为订单表和产品表）
    首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一
    件事情

第三范式(3rd NF－ 不存在对非主键列的传递依赖)

     第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编
    号外，顾客姓名依赖于非主键顾客编号。

## B+ 树 与 B树的不同点

+ 叶子节点互相连接
+ 节点冗余，可以重复出现
+ 一个节点可以有多个数据

InnoDB（B+树）

    InnoDB 底层存储结构为B+树， B树的每个节点对应innodb的一个page，page大小是固定的，
    一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据。
    适用场景：
    1）经常更新的表，适合处理多重并发的更新请求。
    2）支持事务。
    3）可以从灾难中恢复（通过 bin-log 日志等）。
    4）外键约束。只有他支持外键。
    5）支持自动增加列属性 auto_increment。
## 数据库事务

事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起

start transaction；

commit；

rollback；

ACID

    系统提交，要么都执行、要么都不执行 。事务是一个不可分割的工作逻辑单元
    事务必须具备以下四个属性，简称 ACID 属性：
    原子性（Atomicity）
    1. 事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执
    行。
    一致性（Consistency）
    2. 当事务完成时，数据必须处于一致状态。
    隔离性（Isolation）
    3. 对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方
    式依赖于或影响其他事务。
    永久性（Durability）
    4. 事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性

Mysql中不要在事务中使用不同的存储引擎，回滚是MyISAM的变更就无法撤销


## 数据库并发策略

    并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。
  乐观锁
  
    乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自
    己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间
    戳就是不加锁，通过时间戳来控制并发出现的问题。
 悲观锁
 
    悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加
    锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数
    据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允
    许其他用户访问那部分数据。
 时间戳
 
    时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字
    段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数
    据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁
    机制，但是这种方法可以大大提高数据库处理的并发量，
    以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁（写锁）和共享锁（读锁）。


## 数据库锁  并发控制

共享锁（S）： SELECT*FROM table_name WHERE...LOCK IN SHARE MODE。 显式锁定

可以多个事务加S锁，释放了S锁后，才可以加X锁

排他锁（X)： SELECT*FROM table_name WHERE...FOR UPDATE  显式锁定

> 对于 UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)

> MyISAM在执行查询语句 SELECT前，会自动给涉及的所有表加读锁，在执行更新操作（ UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预

### 行级锁(Innodb)  *InnoDB* 根据索引完成行级锁 （是加在索引行的） 

在存储引擎级别实现，不是在服务级别实现

行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时，Oracle 会自动应用行级锁：

    1. INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];
    2. SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新
    3. 使用 COMMIT 或 ROLLBACK 语句释放锁。
    4. 当选中某一个行的时候,如果是通过主键id选中的。那么这个时候是行级锁。
       其他的行还是可以直接insert 或者update的。
       如果是通过其他的方式选中行,或者选中的条件不明确包含主键。
       这个时候会锁表。其他的事务对该表的任意一行记录都无法进行插入或者更新操作。只能读取。*

### 表级锁(Innodb,Mylsam)  相比行级锁有更高的优先级

    表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使
    用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁
    （排他锁）。
    
    ALTER TABLE会使用表级锁，忽略存储引擎的差别

### 页级锁
页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级
冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。Innodb 支持页级锁

### Gap Locks(间隙锁)
间隙锁，它会锁住两个索引之间的区域。比如select * from user where id>1 and id<10 for update，就会在id为(1,10)的索引区间上加Gap Lock。

### Next-Key Locks(间隙锁)
也叫间隙锁，它是Record Lock + Gap Lock形成的一个闭区间锁。比如select * from user where id>=1 and id<=10 for update，  
就会在id为[1,10]的索引闭区间上加Next-Key Lock

可重复读+间隙锁 可避免幻读

##  隔离级别
丢失更新：两个事务同时更新一行数据，最后一个事务的更新会覆盖掉第一个事务的更新，从而导致第一个事务更新的数据丢失，这是由于没有加锁造成的；
 

    1. 脏读 ：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
     e.g.
            1.Mary的原工资为1000, 财务人员将Mary的工资改为了8000(但未提交事务)
            2.Mary读取自己的工资 ,发现自己的工资变为了8000，欢天喜地！
            3.而财务发现操作有误，回滚了事务,Mary的工资又变为了1000
              像这样,Mary记取的工资数8000是一个脏数据。
    
     
    
    2. 不可重复读 ：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
        e.g.
        1.在事务1中，Mary 读取了自己的工资为1000,操作并没有完成
        2.在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务.
        3.在事务1中，Mary 再次读取自己的工资时，工资变为了2000
    
     解决办法：如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。
    
     
    
    3. 幻读 : 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。
       e.g.
       目前工资为1000的员工有10人。
       1.事务1,读取所有工资为1000的员工。
       2.这时事务2向employee表插入了一条员工记录，工资也为1000
       3.事务1再次读取所有工资为1000的员工 共读取到了11条记录，
  
## 事务隔离级别   隐式锁定
  
  事务隔离级别	                脏读	不可重复读	幻读   描述  
  未提交读（read-uncommitted）	是	    是	        是       不会施加任何锁
  >读不加锁，写会加锁，直到当前事务提交 读取最新数据行
  
  不可重复读（read-committed）	否	    是	        是       A查不到B未提交的数据，解决了脏读，B提交后出现不可重复读 
  > *每次读取都是最新的版本*

  可重复读（repeatable-read）	否	    否	        是       使用了MVCC机制，select不更新版本号（历史版本，所以另一个事务新增后，这里查询不到）
  >每次读取都是事务当前的版本

  串行化（serializable）	        否	    否	        否       涉及的所有数据被绑定，加锁读
  > 读数据的时候加了共享锁
  
  mysql默认的事务隔离级别为repeatable-read
  
  set session  transaction isolation level read committed
## MVCC 多版本并发控制器 

保存了每个事务时间点的快照，即每个事务看到的数据都是一致的

使大多数数据不用加锁

        在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号(上次的回滚地址)
        （可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）。
        这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。
        事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。
        
        每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的
  + DATA_TRX_ID
  
  记录最近更新这条行记录的 事务 ID ，大小为  6  个字节
  
  新查询的事务ID必须小于等于这个最新的事务ID，保证此行要么是此事务开始时就存在的要么就是事务自身修改或插入的。
  
  + DATA_ROLL_PTR
  
  表示指向该行回滚段 （rollback segment） 的指针，大小为  7  个字节， InnoDB  便是通过这个指针找到之前版本的数据。该行记录上所有旧版本，在  undo.log  中都通过链表的形式组织。
  
  行的删除版本要么未定义，要么大于当前的事务版本号，保证在事务开始之前未被删除
  
  + DB_ROW_ID
  
  行标识（隐藏单调自增  ID ），大小为  6  字节，如果表没有主键， InnoDB  会自动生成一个隐藏主键，因此会出现这个列。另外，每条记录的头信息（ record header ）里都有一个专门的  bit （ deleted_flag ）来表示当前记录是否已经被删除。
## ReadView 在RC和RR中生成 ReadView的时间是不同的
    在  RC  隔离级别下，每个  SELECT  语句开始时，都会重新将当前系统中的所有的活跃事务拷贝到一个列表生成  ReadView 。二者的区别就在于生成  ReadView  的时间点不同，一个是事务之后第一个  SELECT  语句开始(RR)、一个是事务中每条  SELECT  语句开始(RC)。
    
    ReadView  中是当前活跃的事务  ID  列表，称之为  m_ids ，其中最小值为  up_limit_id ，最大值为  low_limit_id ，事务  ID  是事务开启时  InnoDB  分配的，其大小决定了事务开启的先后顺序，因此我们可以通过  ID  的大小关系来决定版本记录的可见性，具体判断流程如下：
    
    如果被访问版本的  trx_id  小于  m_ids  中的最小值  up_limit_id ，说明生成该版本的事务在  ReadView  生成前就已经提交了，所以该版本可以被当前事务访问。
    
    如果被访问版本的  trx_id  大于  m_ids  列表中的最大值  low_limit_id ，说明生成该版本的事务在生成  ReadView  后才生成，所以该版本不可以被当前事务访问。需要根据  Undo Log  链找到前一个版本，然后根据该版本的 DB_TRX_ID 重新判断可见性。
    
    如果被访问版本的  trx_id  属性值在  m_ids  列表中最大值和最小值之间（包含），那就需要判断一下  trx_id  的值是不是在  m_ids  列表中。如果在，说明创建  ReadView  时生成该版本所属事务还是活跃的，因此该版本不可以被访问，需要查找 Undo Log 链得到上一个版本，然后根据该版本的  DB_TRX_ID  再从头计算一次可见性；如果不在，说明创建  ReadView  时生成该版本的事务已经被提交，该版本可以被访问。
    
    此时经过一系列判断我们已经得到了这条记录相对  ReadView  来说的可见结果。此时，如果这条记录的  delete_flag  为  true ，说明这条记录已被删除，不返回。否则说明此记录可以安全返回给客户端  

## 死锁 

Innodb引擎会检测死锁，并返回一个错误

另一种方式是达到超时时间后放弃锁请求，效果不好

目前为将持有最小行级排他锁的事务进行提交

## CAP
  
        CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability
      （可用性）、Partition tolerance（分区容错性），三者不可得兼。
      一致性（C）：
      1. 在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份
      最新的数据副本）
      可用性（A）：
      2. 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备
      高可用性）
      分区容忍性（P）：
      3. 以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，
      就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。

## 查询过程

1. 客户端发送指令给服务器
   + 通信协议：半双工，不能同时发送
2. 检查是否命中缓存
   + 通过哈希映射实现
3. SQL解析，预处理，优化器生成对应的执行计划
   + 根据关键字解析成语法数
4. 调用API进行查询  
5. 将结果返回

    
## 利用索引
    // 优化前
    
    SELECT id, cu_id, name, info, biz_type
        , gmt_create, gmt_modified, start_time, end_time, market_type
        , back_leaf_category, item_status, picuture_url
    FROM relation
    WHERE biz_type = '0'
        AND end_time >= '2014-05-29'
    ORDER BY id ASC
    LIMIT 149420, 20;
    
    
    // 优化后
    
    SELECT a.*
    FROM relation a, (
            SELECT id
            FROM relation
            WHERE biz_type = '0'
                AND end_time >= '2014-05-29'
            ORDER BY id ASC
            LIMIT 149420, 20
        ) b
    WHERE a.id = b.id
    解释：其实这里就是通过使用覆盖索引查询返回需要的主键,再根据主键关联原表获得需要的数据。这样就是充分利用了索引！
> [优化链接](https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483856&idx=1&sn=ea1c06f0852d3bca3b98b64d8589598e&chksm=ebd740d1dca0c9c77ed1bb07a96bd0fbe147a13515797cf71597de821dbe3357e3eef5f741dc&scene=21###wechat_redirect)

## 索引 
主键索引 PRIMARY KEY：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。注意：一个表只能有一个主键  
唯一索引 UNIQUE：唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。可以通过ALTER TABLE table_name ADD UNIQUE (column);
创建唯一组合索引可以通过ALTER TABLE table_name ADD UNIQUE (column1,column2);  
创建普通索引：ALTER TABLE table_name ADD INDEX index_name (column);  

InnoDB查找顺序 ： 节点页-》叶子页-》逻辑页

## 索引设计的原则

1）适合索引的列是出现在where子句中的列，或者连接子句中指定的列；

2）基数（单个列唯一键（distict_keys）的数量）较小的类，索引效果较差，没有必要在此列建立索引；

3）使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间；

4）不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。


## 索引优化规则：

1）如果MySQL估计使用索引比全表扫描还慢，则不会使用索引。

返回数据的比例是重要的指标，比例越低越容易命中索引。记住这个范围值——30%，后面所讲的内容都是建立在返回数据的比例在30%以内的基础上。

2）前导模糊查询不能命中索引。 %name%不会命中，name%会命中

3）数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来。

4） 复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中符合索引。查询条件中是否包含索引最左列字段：  

5）union、in、or都能够命中索引，建议使用in  

6）用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到 ，  

 > 因为or后面的条件列中没有索引，那么后面的查询肯定要走全表扫描，在存在全表扫描的情况下，就没有必要多一次索引扫描增加IO访问。

7）负向条件查询不能使用索引，可以优化为in查询。
 
 负向条件有：!=、<>、not in、not exists、not like等。
 
8）范围条件查询可以命中索引。范围条件有：<、<=、>、>=、between等。
> 但是范围条件后面的列就不能再命中索引了

9）数据库执行计算不会命中索引。 age+1>24

10）利用覆盖索引进行查询，避免回表。即“被查询列要被所建的索引覆盖”，不要select *，回表的情况会全表扫描

辅助索引存储的是： 辅助索引列+主键。

11）建立索引的列，不允许为null。
> 单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集，所以，请使用not null约束以及默认值。

## sql 分组
```sql

-- 利用了分组的去重，同时如果想查出分组之外的属性，也可以这么子查询 
select * from user where id in(
   select min(id) from user where name = 'Java3y' and pv = 20 and time='7-25' group by name,pv,time;
)
```

## join

+ 在join的时候一定要写关联条件，如果是inner join的话，只有符合关联条件的数据才会存在最大表中
   + 尽量利用inner join 避免where中带in（）子查询

+ 如果是left join的话，即便关联条件不符合，左边表的数据一定会存在大表中

+ 如果是right join的话，即便关联条件不符合，右边表的数据一定会存在大表中

## case when
```sql
SELECT C.* , 
    CASE WHEN C.T_NUMBER = '1' THEN '男' 
        WHEN C.T_NUMBER = '2' THEN '女'
        ELSE '其他'
        END AS '性别'
    FROM DAY20190706 C;
```

## Mysql log

事务日志

+ undo log 回滚和多版本控制(MVCC)
> undo log主要存储的也是逻辑日志，
>比如我们要insert一条数据了，
>那undo log会记录的一条对应的delete日志。我们要update一条记录时，
>它会记录一条对应相反的update记录

+ binlog 记录了数据库表结构和表数据变更,除了select，存储变更的sql和事务id
> 复制和恢复数据
+ redo log 记载着在每个页上做的修改，用来恢复数据 使用Innodb引擎会有
> 实际上Mysql的基本存储结构是页(记录都存在页里边)，
>所以MySQL是先把这条记录所在的页找到，
>然后把该页加载到内存中，将对应记录进行修改。

*Mysql* 需要保证redo log和binlog的一致性，事务也需要两个日志记录都成功才可以

## 表删除
+ 不再需要一张表的时候，用drop
 
+ 想删除部分数据行时候，用delete，并且带上where子句
 
+ 保留表而删除所有数据的时候用truncate

## 索引 页的目录
> 首先Mysql的基本存储结构是页(记录都存在页里边) 各个数据页可以组成一个双向链表，而每个数据页中的记录又可以组成一个单向链表
>所以没有索引：先遍历双向链表在遍历单向链表

### 最左匹配原则：

索引可以简单如一个列 (a)，也可以复杂如多个列 (a,b,c,d)，即联合索引。

如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询 (>、<、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。

因此，列的排列顺序决定了可命中索引的列数

### =、in自动优化顺序

不需要考虑=、in等的顺序，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。

> 一般来说，在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，

（1）是一种快速查询表中内容的机制，类似于新华字典的目录

（2）运用在表中某个些字段上，但存储时，独立于表之外
+ InnoDB使用的是B+Tree。
>B+Tree：每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。
+ 组合索引必须从最左边查 必须从最左边差，不能跳过
+ 不能使用索引中范围条件右边的列，范围查询会导致后面的的索引失效

### InnoDB的聚簇索引：
    InnoDB对主键建立聚簇索引。
    如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。
    如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。
 >聚簇索引：节点页只包含了索引列，叶子页包含了行的全部数据。聚簇索引“就是表”，因此可以不需要独立的行存储

+ 聚集索引在叶子节点存储的是表中的数据

+ 非聚集索引在叶子节点存储的是主键和索引列
### MyISAM建立的索引结构大致如下：

col1主键索引：按照主键大小排序，节点数据为行号。

### explain  优化器解释命令

explain select * from user； 命中索引会在 key中看到索引的名称，也会在filtered中显示查出的比例

type：ref、all（全表扫描）
possible_key: 可能走索引的情况，但是可能回表做了全表扫描
key： 走的索引
key_len: 走索引的长度，如int为4字节，加上空为5字节，则key_len为5

## 查看表中索引
SHOW INDEX FROM user;
## 查看表中的锁和事务 

select * from information_schema.INNODB_LOCKS;

select * from information_schema.INNODB_TRX;

### sql分类
（1）DML（数据操纵语言）：select，insert，update，delete

（2）DDL（数据定义语言）：create table，alter table，drop table，truncate table

（3）DCL（数据控制语言）：grant select any table to scott/revoke select any table from scott

（4）TCL（事务控制语言）：commit，rollback，savepoint to 回滚点


DATETIME	 8 bytes	 YYYY-MM-DD HH:MM:SS
TIMESTAMP	 4 bytes	 YYYY-MM-DD HH:MM:SS	时间戳
DATE	     4 bytes     YYYY-MM-DD	            1000-01-01
TIME	     3 bytes     HH:MM:SS
YEAR	     1 bytes     YYYY

## 字符转数字 

select 0 = 'a'  a字符不识别统一转为0

## 数据库性能及性能优化

性能即响应时间

### 选择优化的数据类型

+ 更小的通常更好
+ 更简单的更好 int》string     date》string
+ 尽量避免空值

充分利用索引和缓存

### 类型

+ 整数 TINYINT(8)  SMALLINT(16)  MEDIUMINT(24)  INT(32)  BIGINT(64) 存储范围为2的N次幂-1的绝对值  
UNSIGNED 属性，不允许为负数

+ 实数类型 DECIMAL支持精确地计算 FLOAT近似计算 DOUBLE近似计算  
每4个字节存储9个数字，都可以指定精度  
可以将精确地位数乘对应的倍数转为整数进行计算  

+ 字符串  
varchar 存储可变长字符串 额外使用1或2个字节记录长度   
更新是可能导致没有更多空间存储，不同引擎处理不一样，InoDB分裂页
InoDB会把过长的varchar存储为blob


char  定长的，采用空格填充，末尾的空格会被截断

+ 二进制字符串 binary 和 varbinary

+ BLOB和TEXT类型 

如果太大会在外部存储

text 能存储2的16次方数据，有排序规则

+ 枚举类型 enum

+ 时间和日期类型 

datetime

2020-08-19 11:05:20

timestamp

4个字节 存储的是时间戳

from_unixtime()函数 将时间戳转为日期
unix_timestamp()函数 将日期转为时间戳

显示值依赖时区

可以用DOUBLE存储秒之后的部分

+ 位类型 BIT

## 大数据量数据仓库

Infobright、TokuDB


## 更快的读，更慢得写

为了提升查询的速度，经常会建一些额外的索引，增加冗余列，甚至是增加缓存表和汇总表。


## 分区表 

在创建表时使用PARTITION BY子句定义每个分区存放的数据

一个表最多有1024个分区

分区表无法使用外键约束

## 命令 和 函数

show table status like 'user' 查询表状态

repair table user 修复表

alter table user engine = InnoDB; 转换引擎，占用I/O资源，并且会丢失外键

show profiles 性能剖析 show profile for query 1

show status 计数器

count（）1.统计列值的数量，count（col）2.统计结果集的行数count（*）


ON DUPLICATE KEY UPDATE 需要有在INSERT语句中有存在主键或者唯一索引的列，并且对应的数据已经在表中才会执行更新操作。  
而且如果要更新的字段是主键或者唯一索引，不能和表中已有的数据重复，否则插入更新都失败。


SHOW FULL PROCESSLIST 查看连接线程状态


## 触发器
在insert、update、或delete时，执行特定的操作

## 窗口函数

[窗口函数](https://blog.csdn.net/weixin_39010770/article/details/87862407)



## 触发器
在insert、update、或delete时，执行特定的操作




## 查询优化器的提示

HIGH_PRIORITY 等

## 优化方案

1.选取最适用的字段属性

2.使用连接（JOIN）来代替子查询(Sub-Queries)

3.使用联合(UNION)来代替手动创建的临时表

4、事务

5、锁定表

6、使用外键

7、使用索引

8、优化的查询语句


## 分库分表

水平切分  一张表的数据存放到3张表中
垂直切分  拆分各业务表
读写分离  主节点写数据，从节点备份