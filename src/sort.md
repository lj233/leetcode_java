# 排序

判断某排序算法是否稳定，我们可以简单理解成：  
排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同

## 冒泡排序

双层循环  
稳定


可优化
```
//装载临时变量
int temp;
​
//记录是否发生了置换， 0 表示没有发生置换、 1 表示发生了置换
int isChange;
​
//外层循环是排序的趟数
for (int i = 0; i < arrays.length - 1; i++) {
​
  //每比较一趟就重新初始化为0
  isChange = 0;
​
  //内层循环是当前趟数需要比较的次数
  for (int j = 0; j < arrays.length - i - 1; j++) {
​
    //前一位与后一位与前一位比较，如果前一位比后一位要大，那么交换
    if (arrays[j] > arrays[j + 1]) {
      temp = arrays[j];
      arrays[j] = arrays[j + 1];
      arrays[j + 1] = temp;
​
      //如果进到这里面了，说明发生置换了
      isChange = 1;
​
    }
  }
  //如果比较完一趟没有发生置换，那么说明已经排好序了，不需要再执行下去了
  if (isChange == 0) {
    break;
  }
}
```


## 选择排序  

遍历剩余数组得到最大值。直接替换



不稳定 

找出最大值或最小值，排在首尾

```
//记录当前趟数的最大值的角标
int pos ;
​
//交换的变量
int temp;
​
//外层循环控制需要排序的趟数
for (int i = 0; i < arrays.length - 1; i++) {
  //新的趟数、将角标重新赋值为0
  pos = 0;
​
  //内层循环控制遍历数组的个数并得到最大数的角标
  for (int j = 0; j < arrays.length - i; j++) {
    if (arrays[j] > arrays[pos]) {
      pos = j;
    }
  }
  //交换
  temp = arrays[pos];
  arrays[pos] = arrays[arrays.length - 1 - i];
  arrays[arrays.length - 1 - i] = temp;
}
```

## 插入排序

插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，  
算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。

3-2-1  
2-3-1  
2-3-3 1-2-3


```
for (int i = 1; i < arrays.length; i++) {
​
  temp = arrays[i];
​
  //如果前一位(已排序的数据)比当前数据要大，那么就进入循环比较[参考第二趟排序]
  int j = i - 1;
​
  while (j >= 0 && arrays[j] > temp) {
​
    //往后退一个位置，让当前数据与之前前位进行比较
    arrays[j + 1] = arrays[j];
​
    //不断往前，直到退出循环
    j--;
​
  }
  //退出了循环说明找到了合适的位置了，将当前数据插入合适的位置中
  arrays[j + 1] = temp;
​
}
```


## 快速排序

快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：  
通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，  
然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

快速排序是面试出现的可能性比较高的，也是经常会用到的一种排序，应该重点掌握。


```
    public static void main(String[] args) {
        int[] arr = {1, 4, 5, 67, 2, 7, 8, 6, 9, 44};
​
        quickSort(arr, 0, 9);
​
        System.out.println("Java3y   " + arr);
​
​
    }
​
    /**
     * 快速排序
     *
     * @param arr
     * @param L   指向数组第一个元素
     * @param R   指向数组最后一个元素
     */
    public static void quickSort(int[] arr, int L, int R) {
        int i = L;
        int j = R;
​
        //支点
        int pivot = arr[(L + R) / 2];
​
        //左右两端进行扫描，只要两端还没有交替，就一直扫描
        while (i <= j) {
​
            //寻找直到比支点大的数
            while (pivot > arr[i])
                i++;
​
            //寻找直到比支点小的数
            while (pivot < arr[j])
                j--;
​
            //此时已经分别找到了比支点小的数(右边)、比支点大的数(左边)，它们进行交换
            if (i <= j) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                i++;
                j--;
            }
        }
        //上面一个while保证了第一趟排序支点的左边比支点小，支点的右边比支点大了。
​
​
        //“左边”再做排序，直到左边剩下一个数(递归出口)
        if (L < j)
            quickSort(arr, L, j);
​
        //“右边”再做排序，直到右边剩下一个数(递归出口)
        if (i < R)
            quickSort(arr, i, R);
    }
```

## 归并排序

来源百度百科：

归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。  
将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

过程描述：

归并过程为：  
比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；  
否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，  
然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，  
接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。

原理：

归并操作的工作原理如下：

第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列

第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置

第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置

重复步骤3直到某一指针超出序列尾

将另一序列剩下的所有元素直接复制到合并序列尾

如果数组是无序的，需要分治拆分数组。

代码见 MergeSort

## 希尔排序 

就是把数列进行分组(不停使用插入排序)，直至从宏观上看起来有序，最后插入排序起来就容易了(无须多次移位或交换)。


## 堆排序

.........建堆，交换....建堆，交换...建堆，交换...建堆，交换.

## 基数排序（桶排序）

基数排序不同与其他的7种排序，其他7种排序本质上都是按照交换或者比较来进行排序，但是基数排序并不是，它是按照分配，回收(分配到不同的位置上，然后回收)..不断分配..回收来进行排序，直到有序..


•	将数组的每一位放进桶子里  
•	回收  
•	循环......  


## 递归

•	递归出口(终止递归的条件)  
•	递归表达式(规律)  
