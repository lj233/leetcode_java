 #线程
 ---
 ## 线程池 
 * 顶级接口是Executor
 * newCachedThreadPool 创建一个可根据需要创建新线程的线程池 终止60秒内未使用的线程
 * newFixedThreadPool  创建一个固定线程数的线程池  无界队列，失败会有新线程代替执行
 * newScheduledThreadPool 安排在给定延迟后执行任务或者定期执行
 * newSingleThreadPool  返回一个单例线程，会在失败或关闭后重新启动一个线程执行下去
 ## 线程生命状态
 ---
 * 线程的生命状态 new Runnable running Blocked dead
 ## 阻塞
 ---
 * 阻塞分为3种 等待队列阻塞 Thread.wait() 同步阻塞 running的线程获取同步锁失败——》锁池 lock pool中  其他阻塞  sleep（） join方法
 
 ## 终止线程的方式
  * 使用 volatile退出标志 ，保证同一时刻只能有一个线程做修改
  * interrupt()阻塞下抛出异常后break退出、运行时将中断标识设置为true，方便isInterrupt()判断
  * stop()线程不安全 ：创建子线程的线程抛出错误并且释放子线程的所有锁
  
## sleep()与wait()区别
---
 * sleep()属于Thread方法，不会释放锁，wait属于Object方法，需要notify唤醒
 
 ## start()和run()的区别
 ---
 * start()真正实现了多线程运行，不需要等待run方法体运行完就可以执行后面的代码
 * run（）是方法体，方法结束，表示线程终止
---
# java锁

   * 乐观锁：读不上锁，写会比较，实现方式cas，非阻塞，会不断获取锁
   * 悲观锁： 读写都上锁。synchronized ,java锁框架AQS先尝试乐观锁，后才是悲观锁
   * 自旋锁： 获取不到锁的线程会不断尝试、这个时间应小于CPU上下文切换的时间
   * Synchronized同步锁，可重入锁（同一线程自动对同一对象或者Class持有锁）
        * 作用范围
            * 作用在方法上时，锁住的是实例的对象this
            * 作用在静态方法时 ，锁住的是Class对象
        *  核心组件
            + Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；
            + Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；
            + Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；
            + OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；
            + Owner：当前已经获取到所资源的线程被称为 Owner；
            + !Owner：当前释放锁的线程。


# ReentrantLock
-----
        1. void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经
        被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁.
        2. boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和
        lock()的区别在于, tryLock()只是"试图"获取锁, 如果锁不可用, 不会导致当前线程被禁用, 
        当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一
        直等待, 在未获得锁之前,当前线程并不继续向下执行. 
        3. void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程
        并不持有锁, 却执行该方法, 可能导致异常的发生.
        4. Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，
        当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。


        
### 区别 
        1. ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会
        被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出
        现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操
        作。
        2. ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要
        使用 ReentrantLock。
        
 -----
 
 ## 非公平锁 
           JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了
          是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非
          程序有特殊需要，否则最常用非公平锁的分配机制。
 ## 公平锁
         
         公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，
         ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。
 
 ## 读写锁 
         读锁
         如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁
         写锁
         如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上
         读锁，写的时候上写锁！
         Java 中读写锁有个接口 java.util.concurrent.locks.ReadWriteLock ，也有具体的实现
         ReentrantReadWriteLock
 
 ## 共享锁和独占锁
         独占锁
         独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。
         独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线
         程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。
         共享锁
         共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种
         乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。

## 重量级锁 mutex Lock

        Synchronized 效率低的原因-底层依赖于操作系统 Mutex Lock 所实现的锁我们称之为
        “重量级锁”。
        
## 轻量级锁 
        锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。
        锁升级
        随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，
        也就是说只能从低到高升级，不会出现锁的降级）。
        “轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，
        轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量
        级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场
        景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀
        为重量级锁。

## 偏向锁 

        Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线
        程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起
        来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级
        锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换
        ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所
        以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻
        量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进
        一步提高性能。
 
## 分段锁  ConcurrentHashMap 


## java中的阻塞队列

            1. ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。
            2. LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。
            3. PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。
            4. DelayQueue：使用优先级队列实现的无界阻塞队列。
            5. SynchronousQueue：不存储元素的阻塞队列。
            6. LinkedTransferQueue：由链表结构组成的无界阻塞队列。
            7. LinkedBlockingDeque：由链表结构组成的双向阻塞队列
            
## volatile 变量可见性和禁止指令重排  因为它直接存放在内存中，不需要拷贝到cpu内存

## 两个线程共享数据 
            将数据冲向为类，并且对数据的操作封装为Synchronized方法。
  
##  ThreadLocal          
 * 1、Thread中有一个map，就是ThreadLocalMap
 *
 * 2、ThreadLocalMap的key是ThreadLocal，值是我们自己设定的   
 
 ## CountDownLatch和CyclicBarrier区别：
     1.countDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次
     
     2.CyclicBarrier的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供reset功能，可以多次使用
     
     3.CountDownLatch 简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用 countDown()方法发出通知后，当前线程才可以继续执行。
    
     4.cyclicBarrier 是所有线程都进行等待，直到所有线程都准备好进入 await()方法之后，所有线程同时开始执行！
    
     5.CountDownLatch 的计数器只能使用一次。而 CyclicBarrier 的计数器可以使用 reset() 方法重置。所以 CyclicBarrier 能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。

## Semaphore 是 synchronized 的加强版，作用是控制线程的并发数量。