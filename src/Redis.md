# Redis
Redis的Server是单线程服务器

Redis是一个开源的，基于内存的数据结构存储，可用作于数据库、缓存、消息中间件

Redis并没有直接使用这些数据结构来实现key-value数据库，而是基于这些数据结构创建了一个对象系统。

[redisM命令介绍](http://doc.redisfans.com/)

## 数据结构

string-->简单的key-value

incr命令时，value可看做int类型，内部存储结构是数组，可以存储二进制文件，是安全的

list-->有序列表(底层是双向链表)-->可做简单队列   lpush、rpush 

其实就是一个每个子元素都是 string 类型的双向链表。链表的最大长度是(2 的 32 次方)。  
支持阻塞

set-->无序列表(去重)-->提供一系列的交集（ sinter ）、并集（ sunion ）、差集（sdiffstore）的命令
    
    通过 hash table 实现的，所以添加、删除和查找的复杂度都是 O(1)。hash table 会随 着添加或者删除自动的调整大小。  
    需要注意的是调整 hash table 大小时候需要同步（获取写 锁）会阻塞其他读写操作，  
    可能不久后就会改用跳表（skip list）来实现，跳表已经在 sorted set 中使用了。  
    关于 set 集合类型除了基本的添加删除操作，其他有用的操作还包含集合的 取并集(union)，交集(intersection)，差集(difference)。  
    通过这些操作可以很容易的实现 sns 中的好友推荐和 blog 的 tag 功能

hash-->哈希表-->存储结构化数据

hash-max-zipmap-entries 64 #配置字段最多 64 个     开始默认为zipmap结构，容量达到一定程度后面才会升级成正常Hash结构 
hash-max-zipmap-value 512 #配置 value 最大为 512 字节 

sortset-->有序集合映射(member-score)-->排行榜

    是每个元素都会关联一个 double 类型的 score。sorted set 的实现是 skip list 和 hash table 的混合体
    当元素被添加到集合中时，一个元素到 score 的映射被添加到 hash table 中，所以给定一个 元素获取 score 的开销是 O(1),另一个 score 
    到元素的映射被添加到 skip list，并按照 score 排 序，所以就可以有序的获取集合中的元素。
    添加，删除操作开销都是 O(log(N))和 skip list 的 开销一致,redis 的 skip list 实现用的是双向链表,这样就可以逆序从尾部取元素。
    sorted set 最 经常的使用方式应该是作为索引来使用.我们可以把要排序的字段作为 score 存储，对象的 id 当元素存储

## 事务控制 

redis 对事务的支持目前还比较简单。redis 只能保证一个 client 发起的事务中的命令可以连 续的执行，而中间不会插入其他 client 的命令。   
由于 redis 是单线程来处理所有 client 的请 求的所以做到这点是很容易的。一般情况下 redis 在接受到一个 client 发来的命令后会立即   
处理并 返回处理结果，但是当一个 client 在一个连接中发出 multi 命令有，这个连接会进入 一个事务上下文，该连接后续的命令并不是立即执行，  
而是先放到一个队列中。当从此连接 受到 exec 命令后，redis 会顺序的执行队列中的所有命令。并将所有命令的运行结果打包到 一起返回给 client.  
然后此连接就 结束事务上下文。 

discard 命令其实就是清空事务的命令队列并退 出事务上下文，也就是我们常说的事务回滚。 

如果在事务队列中，有的命令错了，则不会整体回滚

## 乐观锁 

watch 命令会监视给定的 key,当 exec 时候如果监视的 key 从调用 watch 后发生过变化，则整 个事务会失败。  
也可以调用 watch 多次监视多个 key.这 样就可以对指定的 key 加乐观锁了。  
 注意 watch 的 key 是对整个连接有效的，事务也一样。如果连接断开，监视和事务都会被自 动清除。  
 当然了 exec,discard,unwatch 命令都会清除连接中的所有监视。 

## 集群
客户端的请求会通过负载均衡算法（通常是一致性Hash,引入hash环和虚拟节点的概念），分散到各个Redis服务器上。
[一致性hash算法](https://blog.csdn.net/u010066934/article/details/51984672)

+ 扩大缓存容量；
+ 提升吞吐量；

主从 + 哨兵

## 主从复制 Master-Slave/ (Master/slave chains)
数据高可用：Master负责接收客户端的写入请求，将数据写到Master后，同步给Slave，实现数据备份。一旦Master挂了，可以将Slave提拔为Master；

提高查询效率：一旦Master发现自己忙不过来了，可以把一些查询请求，转发给Slave去处理，也就是Master负责读写或者只负责写，Slave负责读；

主服务器来控制从服务器统一删除过期键。

## Sentinel（哨兵）

> 一个运行在特殊模式下的Redis服务器  
> 初始化时根据指定配置文件监视主服务器列表
> 创建两个连向主服务器的网络连接  

    命令连接(发送和接收命令)
    
    订阅连接(订阅主服务器的sentinel:hello频道)

> 单个发送ping命令判断是否主管下线，多个确认判断是否是客观下线
+ 可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器

+ Redis提供了哨兵(Sentinel)机制供我们解决上面的情况。如果主服务器挂了，  
  我们可以将从服务器升级为主服务器，等到旧的主服务器(挂掉的那个)重连上来，会将它(挂掉的主服务器)变成从服务器。  
  这个过程叫做 ***主备切换*** (故障转移)


## 丢失数据 

> 异步复制导致的数据丢失

有部分数据还没复制到从服务器，主服务器就宕机了，  
此时这些部分数据就丢失了

> 脑裂导致的数据丢失

有时候主服务器脱离了正常网络，跟其他从服务器不能连接。  
此时哨兵可能就会认为主服务器下线了(然后开启选举，将某个从服务器切换成了主服务器)，但是实际上主服务器还运行着。这个时候，集群里就会有两个服务器(也就是所谓的脑裂)。
虽然某个从服务器被切换成了主服务器，  
但是可能客户端还没来得及切换到新的主服务器，客户端还继续写向旧主服务器写数据。旧的服务器重新连接时，会作为从服务器复制新的主服务器(这意味着旧数据丢失)。


可以通过以下两个配置尽量减少数据丢失的可能：

min-slaves-to-write 1
min-slaves-max-lag 10
## 分片
```
分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。
假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。

最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。
还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。

根据执行分片的位置，可以分为三种分片方式：
客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。
代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。
服务器分片：Redis Cluster  
```
[各集群负载均衡算法](https://blog.csdn.net/weixin_43184769/article/details/91443577)

## 持久化命令

+ BGSAVE RDB 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，
    原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。 COW
+  Save RDB 阻塞 命令执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘。

+ BgReWriteOfAOF 命令用于异步执行一个 AOF（AppendOnly File） 文件重写操作（避免aof文件过大）。  
跟快照类似，子进程写入现有数据，主进程在执行时有数据重写缓冲区，子进程完成重写后，让父进程将AOF重写缓冲区的数据写到新的AOF中。

AOF持久化策略：一共有三种，第一个是always（每一个命令，safest），第二个是everysec（每秒，最稳妥），   
第三个是no（不追加，只在操作系统想要刷新时，fasterst），一般选择everysec

默认是先加载AOF


## aof/rdb和复制功能对过期键的处理
rdb

生成rdb文件：生成时，程序会对键进行检查，过期键不放入rdb文件。
载入rdb文件：载入时，如果以主服务器模式运行，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会忽略；  

如果以从服务器模式运行，无论键过期与否，均会载入数据库中，过期键会通过与主服务器同步而删除。
aof

当服务器以aof持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被删除，那么aof文件不会因为这个过期键而产生任何影响；  
当过期键被删除后，程序会向aof文件追加一条del命令来显式记录该键已被删除。
aof重写过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的aof文件中。
复制

当服务器运行在复制模式下时，从服务器的过期删除动作由主服务器控制：

主服务器在删除一个过期键后，会显式地向所有从服务器发送一个del命令，告知从服务器删除这个过期键;
从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键;
从服务器只有在接到主服务器发来的del命令后，才会删除过期键。

## copy-on-write 读共享，写复制

    Redis在持久化时，如果是采用BGSAVE命令或者BGREWRITEAOF的方式，那Redis会fork出一个子进程来读取数据，从而写到磁盘中。
    
    总体来看，Redis还是读操作比较多。如果子进程存在期间，发生了大量的写操作，那可能就会出现很多的分页错误(页异常中断page-fault)，这样就得耗费不少性能在复制上。
    
    而在rehash阶段上，写操作是无法避免的。所以Redis在fork出子进程之后，将负载因子阈值提高，尽量减少写操作，避免不必要的内存写入操作，最大限度地节约内存
    
    
## pipeline

多个命令打包执行，打包返回   
    
 
## Redis缓存策略：

（1）、LRU(回收算法)、LFU、FIFO。

（2）、超时剔除。

（3）、主动更新。

## 缓存问题
```
缓存穿透：就是客户持续向服务器发起对不存在服务器中数据的请求。客户先在Redis中查询，查询不到后去数据库中查询。
缓存击穿：就是一个很热门的数据，突然失效，大量请求到服务器数据库中
缓存雪崩：就是大量数据同一时间失效。
打个比方，你是个很有钱的人，开满了百度云，腾讯视频各种杂七杂八的会员，但是你就是没有netflix的会员，然后你把这些账号和密码发布到一个你自己做的网站上，然后你有一个朋友每过十秒钟就查询你的网站，发现你的网站没有Netflix的会员后打电话向你要。你就相当于是个数据库，网站就是Redis。这就是缓存穿透。
大家都喜欢看腾讯视频上的《水果传》，但是你的会员突然到期了，大家在你的网站上看不到腾讯视频的账号，纷纷打电话向你询问，这就是缓存击穿
你的各种会员突然同一时间都失效了，那这就是缓存雪崩了。

放心，肯定有办法解决的。
缓存穿透：
1.接口层增加校验，对传参进行个校验，比如说我们的id是从1开始的，那么id<=0的直接拦截；
2.缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，这样可以防止攻击用户反复用同一个id暴力攻击
缓存击穿：
最好的办法就是设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员
缓存雪崩：
1.缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
2.如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
```
## 事务 MULTI开始 EXEC 结束 打包成脚本命令 lua？
很多情况下我们需要一次执行不止一个命令，而且需要其同时成功或者失败。
redis对事务的支持也是源自于这部分需求，即支持一次性按顺序执行多个命令的能力，并保证其原子性。(多个指令不支持 )

## 淘汰策略  定期删除漏掉了很多过期key,设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。

```
Redis有哪几种数据淘汰策略？
在Redis中，允许用户设置最大使用内存大小server.maxmemory，当Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。
1.volatile-lru:从已设置过期的数据集中挑选最近最少使用的淘汰
2.volatile-ttl:从已设置过期的数据集中挑选将要过期的数据淘汰
3.volatile-random:从已设置过期的数据集中任意挑选数据淘汰
4.allkeys-lru:从数据集中挑选最近最少使用的数据淘汰
5.allkeys-random:从数据集中任意挑选数据淘汰
6.noenviction:禁止淘汰数据  默认最大内存，淘汰机制
redis淘汰数据时还会同步到aof

```
## 删除策略
> 定时删除(对内存友好，对CPU不友好)

到时间点上就把所有过期的键删除了。

> 惰性删除(对CPU极度友好，对内存极度不友好)

每次从键空间取键的时候，判断一下该键是否过期了，如果过期了就删除。

> 定期删除(折中)  配置文件中 hz 10

每隔一段时间去删除过期键，限制删除的执行时长和频率。

Redis采用的是惰性删除+定期删除两种策略，所以说，在Redis里边如果过期键到了过期的时间了，未必被立马删除的！

## redis 实现分布式锁方案

redission 

1、 执行lua脚本判断是否存在
2、 不存在就 hset key 客户端id:1(当前线程加锁测试)
3、 存在就判断是否是同一线程，不是返回存活时间
4、 加锁后会返回看门狗，每隔10秒检查，不断延长存活时间   

## Redis命令 

### 取最新N个数据
LPUSH log newest_log
LTRIM log 0 99
这个例子模拟了一个日志程序，每次将最新日志 newest_log 放到 log 列表中，并且只保留最新的 100 项。  
注意当这样使用 LTRIM 命令时，时间复杂度是O(1)，因为平均情况下，每次只有一个元素被移除。

### 排行榜应用，取 TOP N 操作 
ZRANGE key start stop [WITHSCORES]

下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。
你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。



### 计数器应用 

Redis 的命令都是原子性的，你可以轻松地利用 INCR，DECR 命令来构建计数器系统


### Pub/Sub 构建实时消息系统 

Redis 的 Pub/Sub 系统可以构建实时的消息系统，比如很多用 Pub/Sub 构建的实时聊天系统 的例子


SUBSCRIBE redisChat 创建 redisChat 频道并订阅

PUBLISH redisChat "Redis is a great caching technique"  发布消息


PUBLISH channel message

将信息 message 发送到指定的频道 channel 。

PSUBSCRIBE pattern [pattern ...]

订阅一个或多个符合给定模式的频道

        # 订阅 news.* 和 tweet.* 两个模式
        
        # 第 1 - 6 行是执行 psubscribe 之后的反馈信息
        # 第 7 - 10 才是接收到的第一条信息
        # 第 11 - 14 是第二条
        # 以此类推。。。
        
        redis> psubscribe news.* tweet.*
        Reading messages... (press Ctrl-C to quit)
        1) "psubscribe"                  # 返回值的类型：显示订阅成功
        2) "news.*"                      # 订阅的模式
        3) (integer) 1                   # 目前已订阅的模式的数量
        
        1) "psubscribe"
        2) "tweet.*"
        3) (integer) 2
        
        1) "pmessage"                    # 返回值的类型：信息
        2) "news.*"                      # 信息匹配的模式
        3) "news.it"                     # 信息本身的目标频道
        4) "Google buy Motorola"         # 信息的内容
        
        1) "pmessage"
        2) "tweet.*"
        3) "tweet.huangz"
        4) "hello"
        
        1) "pmessage"
        2) "tweet.*"
        3) "tweet.joe"
        4) "@huangz morning"
        
        1) "pmessage"
        2) "news.*"
        3) "news.life"
        4) "An apple a day, keep doctors away"


## 虚拟内存的使用 

首先说明下 redis 的虚拟内存与操作系统的虚拟内存不是一码事，但是思路和目的都是相同 的。  
就是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出宝贵的内存空间用于其他 需要访问的数据。  
尤其是对于 redis 这样的内存数据库，内存总是不够用的。除了可以将数 据分割到多个 redis server 外。  
另外的能够提高数据库容量的办法就是使用虚拟内存把那些 不经常访问的数据交换的磁盘上。如果我们的存储的数据总是有少部分数据被经常访问，  
大 部分数据很少被访问，对于网站来说确实总是只有少量用户经常活跃。当少量数据被经常访 问时，使用虚拟内存不但能提高单台 redis server   
数据库的容量，而且也不会对性能造成太 多影响。 
 
redis 没有使用操作系统提供的虚拟内存机制而是自己在实现了自己的虚拟内存机制，

vm-enabled yes                       #开启 vm 功能  
vm-swap-file /tmp/redis.swap            #交换出来的 value 保存的文件路径   
vm-max-memory 1000000              #redis 使用的最大内存上限   
vm-page-size 32                      #每个页面的大小 32 个字节   
vm-pages 134217728                  #最多使用多少页面   
vm-max-threads 4                    #用于执行 value 对象换入换出的工作线程数量 